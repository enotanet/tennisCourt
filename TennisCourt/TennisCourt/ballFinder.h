#ifndef BALL_FINDER_H__
#define BALL_FINDER_H__
#include <opencv2/core/core.hpp>
#include <opencv2/video/background_segm.hpp>
#include <vector>

struct ballCandidate {
  cv::Point2f lastPosition;
  double xDiff;
  double yDiff;
};

struct person {
  cv::Point2f feet[2];
  cv::Point2f head;
  cv::Point2f hands[2]; 
};

struct object {
  cv::Point2f top, bottom, right, left;
  std::vector<int> madeUpOf;
  cv::Point2f centre;
};

// Might be refactored into general object detector. Or some
// common code from ball & person detector.
class BallFinder {
public:
  BallFinder() : playersConsistency(0), frameDifference(1), ballNotSeen(0) {}
  bool addFrame(const cv::Mat &frame, cv::Point2f &ballpos, std::vector<object> &players, 
                          std::vector<cv::Point2f> &candidates);
  bool addFrameNew(const cv::Mat &frame, std::vector<cv::Point2f> &ballpos, 
                      std::vector<object> &players, std::vector<cv::Point2f> &candidates);
  // just for testing
  int mymain(int argc, char *argv[]);

private:
  void updateFrames(const cv::Mat &frame);
  void updatesetsOfIsolatedPoints(std::vector<cv::Point2f> isolatedPts);
  bool oppositeSigns(double a, double b);
  bool isSimilar(double a, double b);
  bool matchesCurrentPath(struct ballCandidate candidate, cv::Point2f point, int frameDifference);
  cv::Point2f findCurrentPosition(ballCandidate candidate, int frameDifference);
  int lowDistanceBetweenContours(int i, int j);
  std::vector< std::vector<cv::Point> > getRepresentatives();
  void printContour(std::vector<cv::Point> contour);
  // we will see if this works
  std::vector<ballCandidate> findBallCandidates(cv::Point2f p);
  bool hasRightTrajectory(cv::Point2f p);
  ballCandidate recoverBallCandidate(cv::Point2f p);
  std::vector<cv::Point2f> getCentres();
  std::vector<cv::Point2f> getIsolatedPoints();
  void updateCurrentPosition(ballCandidate *candidate, cv::Point2f currentPosition, int frameDifference);
  bool findBallNew(std::vector<cv::Point2f> &ballpos, std::vector<cv::Point2f> &candidates);
  bool findBall(cv::Point2f &ballpos, std::vector<cv::Point2f> &candidates);
  void findPossibleBallPositions(int, std::vector<cv::Point2f>&);
  void findPlayers(std::vector<object> &players);
  bool updatePlayerCandidate(object &candidate);
  std::vector<object> findPlayerCandidates();
  bool isClose(object&, cv::Point2f&);
  bool isInside(object&, cv::Point2f&);
  bool isNearby(object&, cv::Point2f&);
  void updateObject(object&, int);
  void printObject(object&);
  void printIsolatedPoints();
  void sortContours();

  // Methods used to get rectangles approximations for players
  void obtainHogCandidates(std::vector<cv::Rect> &foundRect);
  cv::Rect getBoundingRectangle(object &player);
  bool foundCandidate(std::vector<cv::Rect> &candidates, object &player, cv::Rect &result);
  void approxPlayersToRectangles(std::vector<object> &players);

  std::vector<cv::Mat> frames; // will contain last 'numberOfFrames' frames
  std::vector< std::vector<cv::Point2f> > setsOfIsolatedPoints;
  std::vector< std::vector<cv::Point> > contours;
  std::vector< std::vector<cv::Point> > representatives;
  std::vector<bool> notIsolated; 
  std::vector<cv::Point2f> centres;
  static const size_t numberOfFrames = 4; // must be at least 2 (recommended at least 3)
  static const size_t maxCoordinateDiff = 40;
  static const size_t maxDistanceBetweenFrames = 50; // max/min distance the ball has traveled
  static const size_t minDistanceBetweenFrames = 2;
  //static const size_t playersConsistencyThreshold = 4;
  static const size_t isolationThreshold = 35; //if no contour is that close then the contour is isolated
  static const size_t representativeFrequency = 15; // pixel distance between two consecutive 
                                                 // representative points of a given contour
  static const size_t ballContourSizeThreshold = 40; // maximal size of a ball contour
  static const size_t minNumberOfContoursRepresentingPlayer = 10;
  static const size_t playerHeight = 210; // average player height in pixels
  static const size_t playerWidth = 120; // average player width in pixels
  static const size_t playerLength = 400;  
  cv::Point2f lastBallPosition;
  std::vector<struct ballCandidate> ballCandidates;
  std::vector<struct object> playerCandidates;

  size_t playersConsistency;
  size_t frameDifference;
  size_t ballNotSeen;
  cv::Mat fgMask; //fg mask generated by MOG2 method
  cv::BackgroundSubtractorMOG2 pMOG2; //MOG2 Background subtractor
  cv::Mat frame;
};

std::vector<cv::Vec3f> getCircles(cv::Mat img);
bool getCirclesVerify(cv::Mat img);
bool getCirclesTest(cv::Mat *img);

#endif
