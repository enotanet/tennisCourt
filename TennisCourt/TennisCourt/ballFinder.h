#ifndef BALL_FINDER_H__
#define BALL_FINDER_H__
#include <opencv2/core/core.hpp>
#include <opencv2/video/background_segm.hpp>
#include <vector>

struct ballCandidate {
  cv::Point2f lastPosition;
  double xDiff;
  double yDiff;
};

// Might be refactored into general object detector. Or some
// common code from ball & person detector.
class BallFinder {
public:
  BallFinder() : frameDifference(-1) {}
  bool addFrame(const cv::Mat &frame, cv::Point2f &ballpos);

private:
  void updateFrames(const cv::Mat &frame);
  void updatesetsOfIsolatedPoints(std::vector<cv::Point2f> isolatedPts);
  bool oppositeSigns(double a, double b);
  bool isSimilar(double a, double b);
  bool matchesCurrentPath(struct ballCandidate candidate, cv::Point2f point, int frameDifference);
  cv::Point2f findCurrentPosition(ballCandidate candidate, int frameDifference);
  bool hasRightTrajectory(cv::Point2f p);
  ballCandidate recoverBallCandidate(cv::Point2f p);
  std::vector<cv::Point2f> getCentres(std::vector< std::vector<cv::Point> > contours);
  std::vector<cv::Point2f> getIsolatedPoints(std::vector< std::vector<cv::Point> > contours, std::vector<cv::Point2f> centres);
  void updateCurrentPosition(ballCandidate *candidate, cv::Point2f currentPosition, int frameDifference);

  std::vector<cv::Mat> frames; // will contain last 'numberOfFrames' frames
  static const int numberOfFrames = 4;
  std::vector< std::vector<cv::Point2f> > setsOfIsolatedPoints;
  static const int maxCoordinateDiff = 40;
  static const int maxDistanceBetweenFrames = 50;
  static const int minDistanceBetweenFrames = 5;
  std::vector<struct ballCandidate> ballCandidates;
  cv::Mat fgMask; //fg mask generated by MOG2 method
  cv::BackgroundSubtractorMOG2 pMOG2; //MOG2 Background subtractor
  int frameDifference;
};

std::vector<cv::Vec3f> getCircles(cv::Mat img);
bool getCirclesVerify(cv::Mat img);
bool getCirclesTest(cv::Mat *img);

#endif