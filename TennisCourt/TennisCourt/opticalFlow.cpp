#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/video/background_segm.hpp"
#include "opencv2/video/tracking.hpp"
#include <iostream>
#include <sstream>
#include <vector>

using namespace cv;
using namespace std;

void processVideo(char*);

//global variables
vector<Mat> frames; // will contain last 'numberOfFrames' frames
const int numberOfFrames = 6;
vector<vector<Point2f> > setsOfIsolatedPoints;
const int maxCoordinateDiff = 40;
vector<struct ballCandidate> ballCandidates;
Point2f ballPosition;
Mat frame; //current frame
Mat fgMask; //fg mask generated by MOG2 method
BackgroundSubtractorMOG2 pMOG2; //MOG2 Background subtractor
int keyboard;

struct ballCandidate {
  Point2f lastPosition;
  int xDiff;
  int yDiff;
};

int main(int argc, char *argv[])
{
  //create GUI windows
  namedWindow("Frame");

  processVideo(argv[1]);

  //destroy GUI windows
  destroyAllWindows();
  return EXIT_SUCCESS;
}

void updateFrames(Mat frame) {
  frames.insert(frames.begin(), frame);
  if (frames.size() > numberOfFrames) 
    frames.pop_back();
}

void updatesetsOfIsolatedPoints(vector<Point2f> isolatedPts) {
  setsOfIsolatedPoints.insert(setsOfIsolatedPoints.begin(), isolatedPts);
  if (setsOfIsolatedPoints.size() > numberOfFrames) {
    setsOfIsolatedPoints.pop_back();
  }
}

bool oppositeSigns(double a, double b) {
  return (a > 0 && b < 0) || (a < 0 && b > 0);
}

bool isSimilar(double a, double b) {
  if (oppositeSigns(a, b)) return false;
  return abs((b-a) / a) < 0.5;
}

bool matchesCurrentPath(struct ballCandidate candidate, Point2f point) {
  Point2f diff = point - candidate.lastPosition;
  if (!isSimilar(diff.x , candidate.xDiff)) return false;
  if (!isSimilar(diff.y , candidate.yDiff)) return false;
  //candidate.xdiff = diff.x;
  //candidate.ydiff = diff.y;
  //candidate.lastPosition = point;
  return true;
}

Point2f findCurrentPosition(struct ballCandidate candidate) {
  for (Point2f p : setsOfIsolatedPoints[0]) {
    if (matchesCurrentPath(candidate, p)) return p;
  }
  return Point2f(0, 0);
}

void updateCurrentPosition(struct ballCandidate candidate, Point2f currentPosition) {
  candidate.xDiff = currentPosition.x - candidate.lastPosition.x;
  candidate.yDiff = currentPosition.y - candidate.lastPosition.y;
  candidate.lastPosition = currentPosition;
}

void processVideo(char* videoFilename) {
  //create the capture object
  VideoCapture capture(videoFilename);

  if(!capture.isOpened()){
    //error in opening the video input
    cerr << "Unable to open video file: " << videoFilename << endl;
    exit(EXIT_FAILURE);
  }

  vector<vector<Point> > contours;
  int i = 0;
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    if ((char) keyboard == 's') {
      // skip 10 frames
      for (int i = 0; i < 10; ++i) {
         if (capture.read(frame))
          updateFrames(frame);
      }
    }

    //read the current frame
    if(!capture.read(frame)) {
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }
    updateFrames(frame);

    if (i < 240) {
      ++i;
      continue;
    }

    
    
    //update the background model
    pMOG2.operator()(frame, fgMask, 0.01);

    //get the frame number and write it on the current frame
    stringstream ss;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
    ss << capture.get(CV_CAP_PROP_POS_FRAMES);
    string frameNumberString = ss.str();
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

    // do an opening (erosion and dilation) on the mask
    erode(fgMask, fgMask, Mat());
    dilate(fgMask, fgMask, Mat()); 

    findContours(fgMask,contours,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_NONE);
    drawContours(frame,contours,-1,cv::Scalar(0,0,255),2);

    
    vector<Point2f> pointsToTrack;
    //cout << "Number of contours: " << contours.size() << endl;
    for (vector<Point> contour : contours) {
      // for each controur take one point 'representing that contour' 
      Point2f center(0,0);
      int numberOfPoints = contour.size();
      for (Point point : contour) {
        center.x += point.x;
        center.y += point.y;
      }
      center.x = center.x / numberOfPoints;
      center.y = center.y / numberOfPoints;
      pointsToTrack.push_back(center);

      //circle(frame, center, 4, Scalar(0, 255, 0), -1, 8);
    }


    // check for isolated points
    vector<Point2f> isolatedPts;
    for (int i = 0; i < pointsToTrack.size(); ++i) {
      Point2f point = pointsToTrack[i];
      int contourSize = contours[i].size();
      int j = 0;
      for (; j < pointsToTrack.size(); ++j) {
        if (i != j) {
          if (norm(point - pointsToTrack[j]) < 2 * contourSize) {
            break;
          }
        }
      }
      if (j == pointsToTrack.size()) {
        // point is isolated
        isolatedPts.push_back(point);
        //circle(frame, point, 4, Scalar(0, 255, 0), -1, 8);
        cout << contourSize << endl;
        if (point.x < frame.rows && point.y < frame.cols) {
          //Mat part(frame, Range((int) point.x - 10, (int) point.x + 10), Range((int) point.y - 10, (int) point.y + 10));
          //cout << "Mat for point " << endl << part << endl;
        }
      }
    }

    updatesetsOfIsolatedPoints(isolatedPts);


    // check ballCandidates...
    if (ballCandidates.size() == 1) {
      struct ballCandidate candidate = ballCandidates[0];
      Point2f currentPosition = findCurrentPosition(candidate);
      if (norm(currentPosition) != 0) 
        updateCurrentPosition(candidate, currentPosition);
      // what if couldnt retrieve ball?
    } else if (ballCandidates.size() > 1) {
      for (struct ballCandidate candidate : ballCandidates) {
        Point2f currentPosition = findCurrentPosition(candidate);
        if (norm(currentPosition) != 0)
          updateCurrentPosition(candidate, currentPosition);
        // again what if not found??
      }
    } else {
      // no ball candidates so far
    }

    for (int i = 0; i < setsOfIsolatedPoints.size(); ++i) {
      vector<Point2f> points = setsOfIsolatedPoints[i];
      for (Point2f p : points) {
        cout << p << ", ";
      }
      cout << endl;
    }

    for (int i = 0; i < pointsToTrack.size(); ++i) {
      //Mat part(frame, Range((int) pointsToTrack[i].x - 1, (int) pointsToTrack[i].x + 1), Range((int) pointsToTrack[i].y - 1, (int) pointsToTrack[i].y + 1));
      //cout << "Mat for point " << endl << part << endl;
    }

    // prepare args for a call to calcOpticalFlow
    vector<uchar> status;
    vector<float> err;
    TermCriteria termcrit(TermCriteria::COUNT|TermCriteria::EPS,20,0.03);
    Size subPixWinSize(10,10), winSize(31,31);
    vector<Point2f> nextPoints;

    //calcOpticalFlowPyrLK(prevFrame, frame, pointsToTrack, nextPoints, status, err, winSize, 3, termcrit, 0, 0.001);
   

    int size1 = pointsToTrack.size();
    int size2 = nextPoints.size();

    vector<Point2f> ballCandidates;

    /*for (int i = 0; i < pointsToTrack.size(); ++i) {
      cout << "To track point: " << pointsToTrack[i];
      cout << ", next position: " << nextPoints[i] << endl;
      float distance = norm(pointsToTrack[i] - nextPoints[i]);
      cout << "distance: " <<  distance << endl;
      if (distance > 5) {
        // this point is a ball candidate
        //ballCandidates
        circle(frame, pointsToTrack[i], 4, Scalar(0, 255, 0), -1, 8);
        circle(frame, nextPoints[i], 4, Scalar(255, 0, 0), -1, 8);
        line( frame, pointsToTrack[i], nextPoints[i], Scalar( 0, 0, 0 ), 2, 8);
      }
      //circle(frame, nextPoints[i], 4, Scalar(255, 0, 0), -1, 8);
    }*/


    //Point point(1000, 1000);
    //circle(frame, point, 32.0, Scalar( 0, 0, 255 ), -1, 8);
    //show the current frame and the fg masks
    imshow("Frame", frame);
    //imshow("Background", back);
    //imshow("Mask", fgMask);
    //get the input from the keyboard
    keyboard = waitKey( 0 );
  }
  //delete capture object
  capture.release();
}

//int main()
//{
//  VideoCapture cap("video3.avi");
//
//  if (!cap.isOpened()) {
//    cout << "cannot open" << endl;
//    return 1;
//  }
//
//  vector<Point2f> points;
//  Mat prevFrame;
//  Mat prevFrameGray;
//  Mat nextFrame;
//  Mat nextFrameGray;
//  Mat difference;
//  
//  cap.read(nextFrame);
//
//  while(1)
//  {
//    prevFrame = nextFrame.clone();              
//    cap.read(nextFrame); // read a new frame from video
//
//    cvtColor(prevFrame, prevFrameGray, CV_RGB2GRAY);
//    cvtColor(nextFrame, nextFrameGray, CV_RGB2GRAY);
//                          
//    imshow("prev", prevFrameGray); //show prev frame in prev window
//    imshow("next", nextFrameGray); // show next frame in next window
//
//    Mat prevSmooth;
//    Mat nextSmooth;
//
//    GaussianBlur( prevFrameGray, prevSmooth, Size(5,5), 0, 0);
//    GaussianBlur( nextFrameGray, nextSmooth, Size(5,5), 0, 0);
//
//    imshow("prevSmooth", prevSmooth);
//    imshow("nextSmooth", nextSmooth);
//
//    // do some processing?
//    
//    int pressed = waitKey(0);
//    if (pressed == 1048603 || pressed == 27) { // esc was pressed
//      cout << "esc pressed" << endl;
//      break;
//    } else if (pressed == 1048608) {
//      //goodFeaturesToTrack(prevImage, points, 500, 0.01, 5, Mat(), 3, 0, 0.04);
//        
//    } else if (pressed == 100) { // d was pressed
//      absdiff(prevSmooth, nextSmooth, difference);
//      imshow("difference", difference);
//    }
//  }
//  
//  return 0;
//}
