#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/video/background_segm.hpp"
#include "opencv2/video/tracking.hpp"
#include <iostream>
#include <sstream>
#include <vector>

using namespace cv;
using namespace std;

void processVideo(char*);

//global variables
Mat prevFrame; // previous frame
Mat frame; //current frame
Mat back; // background
Mat fgMask; //fg mask fg mask generated by MOG2 method
BackgroundSubtractorMOG2 pMOG2(0, 8, true); //MOG2 Background subtractor
int keyboard;

int main(int argc, char *argv[])
{
  //create GUI windows
  namedWindow("Frame");
  namedWindow("Background");

  processVideo(argv[1]);

  //destroy GUI windows
  destroyAllWindows();
  return EXIT_SUCCESS;
}

void processVideo(char* videoFilename) {
  //create the capture object
  VideoCapture capture(videoFilename);

  if(!capture.isOpened()){
  //error in opening the video input
    cerr << "Unable to open video file: " << videoFilename << endl;
    exit(EXIT_FAILURE);
  }

  vector<vector<Point> > contours;
  int i = 0;
  //read input data. ESC or 'q' for quitting
  while( (char)keyboard != 'q' && (char)keyboard != 27 ){
    prevFrame = frame;
    //read the current frame
    if(!capture.read(frame)) {
      cerr << "Unable to read next frame." << endl;
      cerr << "Exiting..." << endl;
      exit(EXIT_FAILURE);
    }

    if (i < 240) {
      ++i;
      continue;
    }
    //update the background model
    pMOG2.operator()(frame, fgMask, 0.01);
    pMOG2.getBackgroundImage(back);
    //get the frame number and write it on the current frame
    stringstream ss;
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
    ss << capture.get(CV_CAP_PROP_POS_FRAMES);
    string frameNumberString = ss.str();
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

    erode(fgMask, fgMask, Mat());
    dilate(fgMask, fgMask, Mat());

    findContours(fgMask,contours,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_NONE);
    drawContours(frame,contours,-1,cv::Scalar(0,0,255),2);

    vector<Point2f> nextPoints;
    vector<Point2f> pointsToTrack;
    cout << "Number of contours: " << contours.size() << endl;
    for (vector<Point> contour : contours) {
      // for each controur take one point 'representing that contour' 
      cout << "contour, of size " << contour.size() << endl;
      Point2f center(0,0);
      int numberOfPoints = contour.size();
      for (Point point : contour) {
        center.x += point.x;
        center.y += point.y;
      }
      center.x = center.x / numberOfPoints;
      center.y = center.y / numberOfPoints;
      circle(frame, center, 4, Scalar(0, 255, 0), -1, 8);
    }
     
    vector<uchar> status;
    vector<float> err;
    TermCriteria termcrit(TermCriteria::COUNT|TermCriteria::EPS,20,0.03);
    Size subPixWinSize(10,10), winSize(31,31);
    if (prevFrame.empty())
      prevFrame = frame;
    //calcOpticalFlowPyrLK(prevFrame, frame, pointsToTrack, nextPoints, status, err, winSize, 3, termcrit, 0, 0.001);

    //Point point(1000, 1000);
    //circle(frame, point, 32.0, Scalar( 0, 0, 255 ), -1, 8);
    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("Background", back);
    imshow("Mask", fgMask);
    //get the input from the keyboard
    keyboard = waitKey( 0 );
  }
  //delete capture object
  capture.release();
}

//int main()
//{
//  VideoCapture cap("video3.avi");
//
//  if (!cap.isOpened()) {
//    cout << "cannot open" << endl;
//    return 1;
//  }
//
//  vector<Point2f> points;
//  Mat prevFrame;
//  Mat prevFrameGray;
//  Mat nextFrame;
//  Mat nextFrameGray;
//  Mat difference;
//  
//  cap.read(nextFrame);
//
//  while(1)
//  {
//    prevFrame = nextFrame.clone();              
//    cap.read(nextFrame); // read a new frame from video
//
//    cvtColor(prevFrame, prevFrameGray, CV_RGB2GRAY);
//    cvtColor(nextFrame, nextFrameGray, CV_RGB2GRAY);
//                          
//    imshow("prev", prevFrameGray); //show prev frame in prev window
//    imshow("next", nextFrameGray); // show next frame in next window
//
//    Mat prevSmooth;
//    Mat nextSmooth;
//
//    GaussianBlur( prevFrameGray, prevSmooth, Size(5,5), 0, 0);
//    GaussianBlur( nextFrameGray, nextSmooth, Size(5,5), 0, 0);
//
//    imshow("prevSmooth", prevSmooth);
//    imshow("nextSmooth", nextSmooth);
//
//    // do some processing?
//    
//    int pressed = waitKey(0);
//    if (pressed == 1048603 || pressed == 27) { // esc was pressed
//      cout << "esc pressed" << endl;
//      break;
//    } else if (pressed == 1048608) {
//      //goodFeaturesToTrack(prevImage, points, 500, 0.01, 5, Mat(), 3, 0, 0.04);
//        
//    } else if (pressed == 100) { // d was pressed
//      absdiff(prevSmooth, nextSmooth, difference);
//      imshow("difference", difference);
//    }
//  }
//  
//  return 0;
//}
